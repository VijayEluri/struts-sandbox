<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=us-ascii"/>
    <link rel="stylesheet" type="text/css" href="../css/mailreader.css"/>

    <title>A Walking Tour of the Action 2 MailReader Application</title>
</head>

<body>
<blockquote>
<h2>A Walking Tour of the Action 2 MailReader Application</h2>

<p>
    <i>
        This article is meant to introduce a new user to Struts Action 2 by "walking
        through" a simple, but functional, application.
    </i>
</p>

<p>
    <i>
        The Action2 MailReader application is based on the 2.2.2 release of OpenSymphony WebWork
        (soon to be known as Struts Action 2).
        To follow along, you should install the MailReader application on your
        own development workstation (e.g. localhost).
    </i>
</p>

<p>
    <i>
        This article assumes the reader has a basic understanding of the Java
        language, JavaBeans, web applications, and JavaServer Pages. For background on
        these technologies, see the
        <a href="http://struts.apache.org/struts-action/userGuide/preface.html">
            Preface to the Action 1 User Guide</a>.
    </i>
</p>

<hr/>

<p>Logging In</p>

<ul>
    <li>
        <a href="#Welcome">Welcome</a>

        <ul>
            <li><a href="#web.xml">web.xml and resources.properties</a></li>

            <li><a href="#Welcome.do">Welcome.do</a></li>

            <li><a href="#Welcome.java">Welcome Action</a></li>

            <li><a href="#global-results">Global Results</a></li>

            <li><a href="#ApplicationListener.java">ApplicationListener.java</a></li>

            <li><a href="#resources.properties">Message Resources</a></li>

            <li><a href="#Welcome.jsp">Welcome Page</a></li>

        </ul>
    </li>
</ul>

<ul>
    <li>
        <a href="#Logon">Logon</a>
        <ul>

            <li><a href="#Logon.jsp">Logon Page</a></li>

            <li><a href="#Logon-validation.xml">Logon-validation.xml</a></li>

            <li><a href="#Logon.java">Logon.java</a></li>

            <li><a href="#MailreaderSupport.java">MailreaderSupport.java</a></li>

            <li><a href="#Logon.xml">Logon Configuration</a></li>

        </ul>
    </li>
</ul>

<p>Adding and Editing Subscription</p>

<ul>
    <li>
        <a href="#MainMenu">MainMenu</a>

        <ul>
            <li><a href=""></a></li>
        </ul>
    </li>
</ul>

<ul>
    <li>
        <a href="#Registration.do">Registration</a>
        <ul>
            <li><a href="#Registration.java">Registration.java</a></li>
        </ul>
    </li>
</ul>

<p>Creating a New Registration</p>

<ul>
    <li>
        <a href="#Registeration.jsp">Registration.jsp</a>

        <ul>
            <li><a href="#Registration.java">Registration.java</a>
            </li>

            <li><a href="#Edit-SubscriptionAction.java">Subscription.java</a>
            </li>
        </ul>
    </li>

    <li>
        <a href="#Subcription.jsp">Subscription.jsp</a>

        <ul>

            <li><a href="#Subscription.java">SubscriptionSave</a>
            </li>
        </ul>
    </li>

    <li><a href="#Summary">Summary</a></li>
</ul>
<hr/>

<p>
    The premise of the MailReader is that it is the first iteration of a
    portal application.
    This version allows users to register themselves and maintain a set of
    accounts with various mail servers.
    If completed, the application would let users read mail from their
    accounts.
</p>

<p>
    The MailReader application demonstrates registering with an application,
    logging into an application, maintaining a master record, and maintaining
    child records.
    This document walks through the constructs needed to do these things,
    including the server pages, Java classes, and configuration elements.
</p>

<p>
    For more about the MailReader, including alternate implementations and a
    set of formal Use Cases,
    please visit the <a href="http://www.StrutsUniversity.org/MailReader">
    Struts University MailReader site</a>.
</p>

<hr/>
<blockquote>
    <p><font class="hint">
        <strong>JAAS</strong> -
        Note that for compatibility and ease of deployment, the MailReader
        uses "application-based" authorization.
        However, use of the standard Java Authentication and Authorization
        Service (JAAS) is recommended for most applications.
        (See the <a
            href="http://struts.apache.org/struts-action/userGuide/preface.html">
        Preface to the Action 1 User Guide</a> for more about
        authentification technologies.)
    </font></p>
</blockquote>
<hr/>

<p>
    The walkthrough starts with how the initial welcome page is displayed, and
    then steps through logging in, adding and editing subscriptions, and
    creating a new registration.
</p>

<h3><a name="Welcome" id="Welcome">Welcome Page</a></h3>

<p>
    A web application, like any other web site, can specify a list of welcome pages.
    When you open a web application without specifying a particular page, a
    default "welcome page" is served as the response.
</p>

<h4><a name="web.xml" id="web.xml">web.xml</a></h4>

<p>
    When a web application loads,
    the container reads and parses the "Web Application Deployment
    Descriptor", or "web.xml" file.
    The framework plugs into a web application via a servlet filter.
    Like any filter, the Action servlet is deployed via the web.xml.
</p>

<hr/>
<h5>web.xml - The Web Application Deployment Descriptor</h5>
<pre><code>&lt;?xml version="1.0" encoding="ISO-8859-1"?>
    &lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
    "http://java.sun.com/dtd/web-app_2_3.dtd">
    &lt;web-app>

    &lt;display-name>Action2 Mailreader&lt;/display-name>

    <strong>&lt;filter>
        &lt;filter-name>Action2&lt;/filter-name>
        &lt;filter-class>
        com.opensymphony.webwork.dispatcher.FilterDispatcher
        &lt;/filter-class>
        &lt;/filter></strong>

    &lt;filter-mapping>
    &lt;filter-name><strong>Action2</strong>&lt;/filter-name>
    &lt;url-pattern>/*&lt;/url-pattern>
    &lt;/filter-mapping>

    &lt;listener>
    &lt;listener-class>
    org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class>
    &lt;/listener>

    &lt;!-- Application Listener for MailReader database -->
    &lt;listener>
    &lt;listener-class>
    mailreader2.ApplicationListener
    &lt;/listener-class>
    &lt;/listener>

    &lt;welcome-file-list>
    &lt;welcome-file>index.html&lt;/welcome-file>
    &lt;/welcome-file-list>

    &lt;/web-app></code></pre>
<hr/>

<p>
    Among other things,
    the web.xml specifies the "Welcome File List" for an application.
    When a web address refers to a directory rather than an individual file,
    the container consults the Welcome File List for the name of a page to
    open by default.
</p>

<p>
    However, most Action 2 applications do not refer to physical pages,
    but to "virtual resources" called <i>actions</i>.
    Actions specify code that we want to be run before a page
    or other resource renders the response.
    An accepted practice is to never link directly to server pages,
    but only to logical action mappings.
    By linking to actions, developers can often "rewire" an application
    without editing the server pages.
</p>

<hr/>
<h5>Best Practice:</h5>
<blockquote>
    <p><font class="hint">"Link actions not pages."</font></p>
</blockquote>
<hr/>

<p>
    The actions are listed in one or more XML configuration files,
    the default configuration file being named "xwork.xml".
    XWork is a command processing framework that underlies Action 2.
    XWork is not bound to the web layer, making it easier to test.
    Among other things, XWork handles the mapping of a request for a certain
    page to a certain action mapping.
</p>

<p>
    Sites can list zero or more "Welcome" pages in the web.xml.
    Unless you are using Java 1.5, actions cannot be specified as a Welcome
    page.
    So, in the case of a Welcome page,
    how do we follow the best practice of navigating through actions
    rather than pages?
</p>

<p>
    One solution is to use a page to "bootstrap" one of our actions.
    A Java web application recognizes the idea of "forwarding" from one page
    to another page (or action).
    We can register the usual "index.html" as the Welcome page and have it
    forward to a "Welcome" action.
</p>

<hr/>
<h5>MailReader's index.html</h5>
<pre><code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
    &lt;html>&lt;head>
    &lt;META HTTP-EQUIV="Refresh" CONTENT="0;<strong>URL=Welcome.do</strong>">
    &lt;/head>
    &lt;body>
    &lt;p>Loading ...&lt;/p>
    &lt;/body>&lt;/html></code></pre>
<hr/>

<p>
    As an alternative, we could also have used a JSP page that issued the redirect with Action2 tags,
    but a plain HTML solution works just as well.
</p>

<h4><a name="Welcome.do" id="Welcome.do">Welcome.do</a></h4>

<p>
    When the client requests "Welcome.do", the request is passed to the "Action2" FilterDispatcher
    registered in the web.xml file.
    The FilterDispatcher passes the request back to XWork to retrieve the appropriate
    action mapping.
    If we just wanted to forward to the Welcome page, we could use a simple
    configuration element.
</p>
<hr/>
<h5>A simple "forward thru" action element</h5>
<pre><code>&lt;action name="<strong>>Welcome</strong>">
    &lt;result><strong>/pages/Welcome.jsp</strong>&lt;/result>
    &lt;/action></code></pre>
<hr/>

<p>
    If a client asks for the Welcome action ("/Welcome.do"), the /page/Welcome.jsp
    page would be returned in response.
    The client does not know, or need to know, that the physical resource is located at
    "/pages/Welcome.jsp".
    All the client knows is that it requested the resource "/Welcome.do".
</p>

<p>
    But if we peek at the configuration file for the MailReader,
    we find a slightly more complicated XML element for the Welcome action.
</p>

<hr/>
<h5>The Welcome action element</h5>
<pre><code>&lt;action name="Welcome" <b>class="mailreader2.Welcome"</b>>
    <strong>&lt;interceptor-ref name="defaultStack"/></strong>
    &lt;result>/pages/Welcome.jsp&lt;/result>
    &lt;/action></code></pre>
<hr/>

<p>
    Here, the <strong>Welcome</strong> Java class executes whenever
    someone asks for the Welcome action.
    As it completes, the Action class can select which "result" is displayed.
    The default result name is "success".
    Another available result, defined at a global scope, is "error".
</p>

<hr/>
<h5>Key concept:</h5>
<blockquote>
    <p>
        The Action class doesn't need to know what result type is needed
        for "success" or "error".
        The Action can just return the logical name for a result,
        without knowing how the result is implemented.
    </p>
</blockquote>
<hr/>

<p>
    The net effect is that all of the result details,
    including the paths to server pages,
    can be maintained in the configuration file.
    Tightly coupled implementation details are not scattered all over
    the application.
</p>

<h4><a name="Welcome.java" id="Welcome.java">Welcome Action</a></h4>

<p>
    OK ... but why would a Welcome Action want to choose between "success" and
    "error"?
</p>

<p>
    The MailReader application retains a list of users along with their email
    accounts.
    The application stores this information in a database.
    If the application can't connect to the database, the application can't do
    its job.
    So before displaying the Welcome <strong>page</strong>, the Welcome
    <strong>class</strong> checks to see if the database is available.
</p>

<p>
    The MailReader is also an internationalized application.
    So, the Welcome Action class checks to see if the message resources are
    available too.
    If both resources are available, the class passes back the "success" token.
    Otherwise, the class passes back the "error" token,
    so that the appropriate messages can be displayed.
</p>

<hr/>
<h5>The Welcome Action class</h5>
<pre><code>package mailreader2;

    public class Welcome extends MailreaderSupport {

    public String execute() {

    // Confirm message resources loaded
    String message = getText(Constants.ERROR_DATABASE_MISSING);
    if (Constants.ERROR_DATABASE_MISSING.equals(message)) {
    addActionError(Constants.ERROR_MESSAGES_NOT_LOADED);
    }

    // Confirm database loaded
    if (null==getDatabase()) {
    addActionError(Constants.ERROR_DATABASE_NOT_LOADED);
    }

    if (hasErrors()) {
    return ERROR;
    }
    else {
    return SUCCESS;
    }
    }
    }</code></pre>
<hr/>

<p>
    Several common result name are predefined
    including ERROR, SUCCESS, LOGIN, NONE, and INPUT,
    so that these tokens can be used consistently across Action 2 applications.
</p>


<h4><a name="global-results" id="global-results">Global Results</a></h4>

<p>
    As mentioned, "error" is defined in a global scope.
    Other actions may have trouble connecting to the database later,
    or other unexpected errors may occur.
    The MailReader defines the "error" result as a Global Result,
    so that any action can use it.
</p>

<hr/>
<h5>MailReader's global-result element</h5>
<pre><code> &lt;global-results>
    &lt;result name=<strong>"error"</strong>><strong>/pages/Error.jsp</strong>&lt;/result>
    &lt;result name="invalid.token">/pages/Error.jsp&lt;/result>
    &lt;result name="login" type="redirect-action">Logon!input&lt;/result>
    &lt;/global-results></code></pre>
<hr/>

<p>
    Of course, if an individual action mapping defines its own "error" result type,
    the local result would be used instead.
</p>

<h4><a name="ApplicationListener.java" id="ApplicationListener.java">ApplicationListener.java</a>
</h4>

<p>
    The database is exposed as an object stored in application scope.
    The database object is based on an interface.
    Different implementations of the database could be loaded without changing
    the rest of the application.
    But how is the database object loaded in the first place?
</p>

<p>
    The database is created by a custom Listener that we configured in the web.xml.
</p>

<hr/>
<h5>mailreader2.ApplicationListener</h5>
<pre><code> &lt;listener>
    &lt;listener-class>
    <strong>mailreader2.ApplicationListener</strong>
    &lt;/listener-class>
    &lt;/listener></code></pre>
<hr/>

<p>
    By default, our ApplicationListener loads a "MemoryDatabase"
    implementation of the UserDatabase.
    MemoryDatabase stores the database content as a XML document,
    which is parsed and loaded as a set of nested hashtables.
    The outer table is the list of user objects, each of which has its own
    inner hashtable of subscriptions.
    When you register, a user object is stored in this hashtable.
    When you login, the user object is stored within the session context.
</p>

<p>
    The database comes seeded with a sample user.
    If you check the database.xml file under /src/java, you'll see the sample
    user described in XML.
</p>

<hr/>
<h5>The "seed" user element from the MailReader database.xml</h5>
<pre><code>&lt;user username="<strong>user</strong>" fromAddress="John.User@somewhere.com"
    fullName="<strong>John Q. User</strong>" password="pass">
    &lt;subscription host="<strong>mail.hotmail.com"</strong> autoConnect="false"
    password="bar" type="pop3" username="user1234">
    &lt;/subscription>
    &lt;subscription host="<strong>mail.yahoo.com</strong>" autoConnect="false" password="foo"
    type="imap" username="jquser">
    &lt;/subscription>
    &lt;/user></code></pre>
<hr/>

<p>
    The "seed" user element creates a registration record for "John Q. User",
    with the subscription detail for his hotmail and yahoo accounts.
</p>

<h4><a name="resources.properties" id="resources.properties">Message Resources</a>
</h4>

<p>
    As mentioned, MailReader is an internationalized application.
    The message resources for the application are loaded through a reference in the
    webwork.properties file.
    Like the database contents, the webwork.properties file is kept under
    /src/java/ in the source tree.
</p>

<hr/>
<h5>webwork.properties</h5>
<pre><code>webwork.custom.i18n.resources = <strong>resources</strong>
    webwork.action.extension = <strong>do</strong></code></pre>
<hr/>

<p>
    When we specify "resources" here, we are telling the framework to scan the classpath
    for a Resource Bundle named "resources.properties".
    The bundle might be embedded in a JAR, or found in the WEB-INF/classes
    folder, or anywhere else on the runtime classpath.
    In the MailReader, we keep the original bundle in the source tree under
    "src/java/" from where it is copied to "WEB-INF/classes" at deployment.
</p>

<p>
    If you change a message in the resource, and then reload the application,
    the change will appear throughout the application.
    If you provide message resources for additional locales, you can
    internationalize your application.
    The MailReader provides resources for English, Russian, and Japanese.
</p>

<hr/>
<h5>Message Resource entries used by the Welcome page</h5>
<pre><code><strong>index.heading=</strong>MailReader Application Options
    <strong>index.logon=</strong>Log on to the MailReader Application
    <strong>index.registration=</strong>Register with the MailReader Application
    <strong>index.title=</strong>MailReader Demonstration Application
    <strong>index.tour=</strong>A Walking Tour of the MailReader Demonstration Application</code></pre>
<hr/>

<h4><a name="Welcome.jsp" id="Welcome.jsp">Welcome Page</a></h4>

<p>
    After confirming that the necessary resources exist, the Welcome action
    forwards to the Welcome page.
</p>
<hr/>
<h5>Welcome.jsp</h5>
<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8" %>
    <strong>&lt;%@ taglib uri="/webwork" prefix="saf" %></strong>
    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    &lt;head>
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    &lt;title><strong>&lt;saf:text name="index.title"/></strong>&lt;/title>
    &lt;link href="<strong>&lt;saf:url value="/css/mailreader.css"/></strong>" rel="stylesheet"
    type="text/css"/>
    &lt;/head>

    &lt;body>
    &lt;h3>&lt;saf:text name="index.heading"/>&lt;/h3>

    &lt;ul>
    &lt;li>&lt;a href="&lt;saf:url action="Registration!input"/>">&lt;saf:text
    name="index.registration"/>&lt;/a>&lt;/li>
    &lt;li>&lt;a href="&lt;saf:url action="Logon!input"/>">&lt;saf:text
    name="index.logon"/>&lt;/a>&lt;/li>
    &lt;/ul>

    &lt;h3>Language Options&lt;/h3>
    &lt;ul>
    &lt;li>&lt;a href="&lt;saf:url action="Welcome?request_locale=en"/>">English&lt;/a>&lt;/li>
    &lt;li>&lt;a href="&lt;saf:url action="Welcome?request_locale=ja"/>">Japanese&lt;/a>&lt;/li>
    &lt;li>&lt;a href="&lt;saf:url action="Welcome?request_locale=ru"/>">Russian&lt;/a>&lt;/li>
    &lt;/ul>

    &lt;hr />

    &lt;p><strong>&lt;saf:i18n name="alternate"></strong>
    &lt;img src="&lt;saf:text name="struts.logo.path"/>"
    alt="&lt;saf:text name="struts.logo.alt"/>"/>
    <strong>&lt;/saf:i18n></strong>&lt;/p>

    &lt;p>&lt;a href="&lt;saf:url action="Tour" />">&lt;saf:text name="index.tour"/>&lt;/a>&lt;/p>

    &lt;/body>
    &lt;/html></code></pre>
<hr/>

<p>
    At the top of the Welcome page, there are several directives that load the
    Action 2 tag libraries.
    These are just the usual red tape that goes with any JSP file.
    The rest of the page utilizes three Action three JSP tags:
    "text", "url", and "i18n".
</p>

<p>
    (We use the tag prefix "saf:" in the Ation2 MailReader application,
    but you can use whatever prefix you like in your applications.)
</p>

<p>
    The <strong>text</strong> tag inserts a message from and
    application's default resource bundle.
    If the framework's locale setting is changed for a user,
    the text tag will render messages from the new locale's resource
    bundle instead.
</p>

<p>
    The <strong>url</strong> tag can render a reference to an
    action or any other web resource,
    applying "URL encoding" to the hyperlinks as needed.
    Java's URL encoding feature lets your application maintain client state
    without requiring cookies.
</p>

<hr/>
<h5>Tip:</h5>
<blockquote>
    <p><font class="hint">
        <strong>Cookies</strong> -
        If you turn cookies off in your browser, and then reload your browser
        and this page,
        you will see the links with the Java session id information attached.
        (If you are using Internet Explorer and try this,
        be sure you reset cookies for the appropriate security zone,
        and that you disallow "per-session" cookies.)
    </font></p>
</blockquote>
<hr/>

<p>
    The <strong>i18n</strong> tag provides access to multiple resource bundles.
    The MailReader application uses a second set of message resources for
    non-text elements.
    When these are needed, we use the &lt;i18n> tag to specify a
    different bundle.
</p>

<p>
    The "alternate" bundle is stored next to the default "resources" bundle,
    so that it ends up under classes, which is on the application's class path.
</p>

<p>
    In the span of a single request for the Welcome page, the framework has done
    quite a bit already:
</p>

<ul>
    <li>
        Confirmed that required resources were loaded during initialization.
    </li>

    <li>
        Written all the page headings and labels from internationalized
        message resources.
    </li>

    <li>
        Automatically URL-encoded paths as needed.
    </li>
</ul>

<p>
    When rendered, the Welcome page lists two menu options:
    one to register with the application and one to login in (if you have
    already registered).
    Let's follow the Login link first.
</p>

<h3><a name="Logon" id="Logon">Logon</a></h3>

<p>
    If you choose the Logon link, and all goes well, the Logon action forwards
    control to the Logon page.
</p>

<h4><a name="Logon.jsp" id="Logon.jsp">Logon Page</a></h4>

<p>
    The Logon page displays a form that accepts a username and password.
    You can use the default username and password to logon (user and pass) if
    you like.
</p>

<p>
    Note that both the username and password are case sensitive.
    Better yet, try omitting or misspelling the username and password in
    various combinations to see how the application reacts.
</p>

<hr/>
<h5>Login.jsp</h5>
<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8" %>
    &lt;%@ taglib uri="/webwork" prefix="saf" %>
    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    &lt;head>
    &lt;title>&lt;saf:text name="logon.title"/>&lt;/title>
    &lt;link href="&lt;saf:url value="/css/mailreader.css"/>" rel="stylesheet"
    type="text/css"/>
    &lt;/head>

    &lt;body onLoad="self.focus();document.Logon.username.focus()">

    <strong>&lt;saf:actionerror/></strong>
    <strong>&lt;saf:form method="POST" validate="true"></strong>

    <strong>&lt;saf:textfield label="%{getText('username')}" name="username"/></strong>
    <strong>&lt;saf:password label="%{getText('password')}" name="password"/></strong>
    <strong>&lt;saf:submit value="%{getText('button.save')}"/></strong>
    <strong>&lt;saf:reset value="%{getText('button.reset')}"/></strong>
    &lt;saf:submit <strong>action="Logon!cancel" onclick="form.onsubmit=null"</strong>
    value="%{getText('button.cancel')}"/>

    &lt;/saf:form>

    &lt;jsp:include page="Footer.jsp"/>
    &lt;/body>
    &lt;/html></code></pre>
<hr/>

<p>
    We already saw some of the tags used by the Logon page on the Welcome page.
    Let's focus on the new tags.
</p>

<p>
    The first new tag on the Logon page is <strong>actionerrors</strong>.
    Most of the possible validation errors are related to a single field.
    If you don't enter a username,
    the framework can place an error message near the tag prompting you to
    enter a username.
    But some messages are not related to a single field.
    For example, the database might be down.
    If the action returns an "Action Error", as opposed to a "Field Error",
    the message is rendered in place of the "actionerror" tag.
    The text for the validation errors, whether they are Action Errors or
    Field Errors, can be specified in the resource bundle,
    making the messages easy to localize.
</p>

<p>
    The second new tag is <strong>form</strong>.
    This tag renders a HTML form tag.
    By default, the form will submit back to whatever action invoked the page.
    The "validate=true" setting enables client-side validation,
    so that the form can be validated with JavaScript before being sent
    back to the server.
    The framework will still validate the form again, just to be sure, but the
    client-side validation can save a few round-trips to the server.
    You can use the method attribute to designate "GET" or "POST",
    just like the HTML form tag.
</p>

<p>
    Within the form tag,
    we see five more new tags: "textfield", "password", "submit",
    and "reset". We also see a second form of "submit" that utilizes an
    "action" attribute.
</p>

<p>
    When we place a control on a form, we usually need to place a set of
    HTML tags to do everything we want to do.
    Usually, we do not just want a plain "input type=text" tag.
    We want the input field to have a label too, and possibly
    a tooltip. And, of course, a place to print a message
    should invalid data be entered.
</p>

<p>
    The UI Tags support templates and themes so that a set of HTML tags can be
    rendered from a single UI Tag. For example, the single tag
</p>

<pre><code>
    &lt;saf:textfield label="%{getText('username')}" name="username"/>
</code></pre>

<p>
    generates a wad of HTML markup.
</p>

<hr/>
<pre><code>&lt;tr>
    &lt;td class="tdLabel">&lt;label for="Logon_username" class="label">Username:&lt;/label>&lt;/td>
    &lt;td>
    &lt;input type="text" name="username" value="" id="Logon_username"/>
    &lt;/td>
    &lt;/tr></code></pre>
<hr/>

<p>
    If for some reason you don't like the markup generated by a UI Tag,
    each tag is driven by an easy-to-edit template,
    that can be updated on a tag-by-tag basis.
    For example, here is the default template that generates the markup for the ActionErrors tag:
</p>

<hr/>
<pre><code>&lt;#if (actionErrors?exists && actionErrors?size > 0)>
    &lt;ul>
    &lt;#list actionErrors as error>
    &lt;li>&lt;span class="errorMessage">${error}&lt;/span>&lt;/li>
    &lt;/#list>
    &lt;/ul>
    &lt;/#if></code></pre>

<p>
    If you wanted ActionErrors displayed in a table instead of a list,
    you could edit a copy of this file, save it under the file name "actionerror.ftl",
    and place this one file somewhere on your classpath.
</p>

<hr/>
<pre><code>&lt;#if (actionErrors?exists && actionErrors?size > 0)>
    &lt;table>
    &lt;#list actionErrors as error>
    &lt;tr>&lt;td>&lt;span class="errorMessage">${error}&lt;/span>&lt;/td>&lt;/tr>
    &lt;/#list>
    lt;/table>
    &lt;/#if></code></pre>
<hr/>

<p>
    Under the covers, the framework uses
    <a href="http://freemarker.sourceforge.net/">Freemarker</a>
    for its standard templating language.
    FreeMarker is similar to
    <a href="http://jakarta.apache.org/velocity/">Velocity</a>,
    but offers better error reporting and some additional features.
    If you prefer, Velocity and JSP templates can also be used to create your own UI Tags.
</p>

<p>
    The <strong>password</strong> tag renders a "input type=password"
    tag, along with the usual template/theme markup.
    By default, the password tag will not retain input if the submit fails.
    If the username is wrong,
    the client will have to enter the password again too.
    If you did want to retain the password when validation fails,
    you can set the tag's "showPassword" property to true.
</p>

<p>
    Unsurprisingly, the <strong>submit</strong> and <strong>reset</strong> tags
    render buttons of the corresponding types.
</p>

<p>
    The second submit button is more interesting.
</p>

<pre><code>  &lt;saf:submit <strong>action="Logon!cancel" onclick="form.onsubmit=null"</strong>
    value="%{getText('button.cancel')}"/>
</code></pre>

<p>
    Here we are creating the Cancel button for the form.
    The button's attribute <em>action="Logon!cancel"</em> tells the framework to submit
    to the Logon's "cancel" method instead of the usual "execute" method.
    The <em>onclick="form.onsubmit=null"</em> script defeats client-side validation.
    On the server side, "cancel" is on a special lists of aliases that bypass validation,
    so the request will go directly to the Action's cancel method.
    (Other special aliases on the bypass list include "input" and "back".)
</p>

<hr/>
<h5>Tip:</h5>
<blockquote>
    <p><font class="hint">
        The UI tags have options and capabilities beyond what we have shown here.
        For more see, the <a href="http://wiki.opensymphony.com/display/WW/Tags">UI Tag documentation.</a>
    </font></p>
</blockquote>
<hr/>

<p>
    OK, but how do the UI Tags know that both of these fields are required?
    How do they know what message to display when the fields are empty?
</p>

<p>
    For the answers, we need to look at another flavor of configuration file:
    the "validation" file.
</p>

<h4><a name="Logon-validation.xml" id="Logon-validation.xml">Logon-validation.xml</a>
</h4>

<p>
    While it is not hard to code data-entry validation into an Action class,
    the framework provides an even easier way to validate input.
</p>

<p>
    The validation framework is configured through another XML document, the <strong>
    Logon-validation.xml</strong>.
</p>

<hr/>
<h5>Validation file for Logon Action</h5>
<pre><code>&lt;!DOCTYPE validators PUBLIC "-//OpenSymphony Group//XWork Validator 1.0.2//EN"
    "http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd">
    &lt;validators>
    &lt;field name="<strong>username</strong>">
    &lt;field-validator type="<strong>requiredstring</strong>">
    &lt;message key="<strong>error.username.required</strong>"/>
    &lt;/field-validator>
    &lt;/field>
    &lt;field name="<strong>password</strong>">
    &lt;field-validator type="<strong>requiredstring</strong>">
    &lt;message key="<strong>error.password.required</strong>"/>
    &lt;/field-validator>
    &lt;/field>
    &lt;/validators>
</code></pre>
<hr/>

<p>
    The field elements correspond to the ActionForm properties.
    The <strong>username</strong> and <strong>password</strong> field elements
    say that each depends on the "requiredstring" validator.
    If the username is blank or absent, validation will fail and an error
    message is generated.
    The messages would be based on the "error.username.required" or
    "error.password.required" message templates, from the resource bundle.
</p>

<!--
<p>
    The <strong>password</strong> field (or property) is also required.
    In addition, it must also pass the "maxlength" and "minlength"
    validations.
    Here, the minimum length is three characters and the maximum length is
    sixteen.
    If the length of the password doesn't meet these criteria, a corresponding
    error message is generated.
    Of course, the messages are generated from the MessageResource bundles and
    are easy to localize.
</p>
-->

<h4><a name="Logon.java" id="Logon.java">Logon Action</a></h4>

<p>
    If validation passes, the framework invokes the execute method of the Logon Action.
    The actual Logon Action is brief, since most of the functionality derives
    from the base class, MailreaderSupport.
</p>

<hr/>
<h5>Logon.java</h5>
<pre><code>package mailreader2;
    import org.apache.struts.apps.mailreader.dao.User;

    public final class <strong>Logon</strong> extends MailreaderSupport {

    public String <strong>execute()</strong> throws ExpiredPasswordException {

    User user = <strong>findUser(getUsername(), getPassword());</strong>

    if (user != null) {
    <strong>setUser(user);</strong>
    }

    if (<strong>hasErrors()</strong>) {
    return INPUT;
    }

    return SUCCESS;
    }
    }</code></pre>
<hr/>

<p>
    Logon lays out what we do to authenticate a user.
    We try to find the user using the provided credentials.
    If the user is found, we cache a reference.
    If not user is not found, we return "input" so the client can try again.
    Otherwise, we return "success", so that the client can access the rest of the application.
</p>

<h4><a name="MailreaderSupport.java" id="MailreaderSupport.java">MailreaderSupport.java</a></h4>

<p>
    Let's look at the relevant properties and methods from the MailreaderSupport and ActionSupport classes:
    "getUsername", "getPassword", "findUser", "setUser", and "hasErrors".
</p>

<p>
    The framework lets you define
    <a href="http://struts.apache.org/struts-action/userGuide/preface.html#javabeans">JavaBean properties</a>
    directly on the Action.
    Any JavaBean property can be used, including rich objects.
    When a request comes in,
    any public properties on the Action class are matched with the request parameters.
    When the names match, the request parameter value is set to the JavaBean property.
    The framework will make its best effort to convert the data,
    and, if necessary, reporting any conversion errors.
</p>

<p>
    The <strong>Username</strong> and <strong>Password</strong> properties are nothing fancy,
    just standard JavaBean properties.
</p>

<hr/>
<h5>MailreaderSupport.getUsername() and getPassword()</h5>
<pre><code>private String username = null;
    public String <strong>getUsername()</strong> {
    return this.username;
    }
    public void setUsername(String username) {
    this.username = username;
    }

    private String password = null;
    public String <strong>getPassword()</strong> {
    return this.password;
    }
    public void setPassword(String password) {
    this.password = password;
    }</code></pre>
<hr/>

<p>
    We use these properties to capture the client's credentials,
    and pass them to the more interesting <strong>findUser</strong> method.
</p>

<hr/>
<h5>MailreaderSupport.findUser</h5>
<pre><code>public User <strong>findUser</strong>(String username, String password)
    throws <strong>ExpiredPasswordException</strong> {

    User user = <strong>getDatabase().findUser(username)</strong>;
    if ((user != null) && !user.getPassword().equals(password)) {
    user = null;
    }
    if (user == null) {
    this.<strong>addFieldError</strong>("password", getText("error.password.mismatch"));
    }
    return user;
    }</code></pre>
<hr/>

<p>
    The findUser method dips into the MailReader Data Access Object layer,
    which is represented by the <strong>Database</strong> property.
    The code for the DAO layer is maintained as a seperate project.
    The MailReader application imports the DAO JAR,
    but it is not responsible for maintaining any of the DAO source.
    Keeping the data access layer at "arms-length" is a very good habit.
    It encourages a style of development where the data access layer
    can be tested and developed independantly of a specific end-user application.
    In fact, there are three versions of the MailReader application,
    all which share the same MailReader DAO JAR!
</p>

<hr/>
<h5>Best Practice:</h5>
<blockquote>
    <p><font class="hint">"Strongly separate data access and business logic from the rest of the application."</font>
    </p>
</blockquote>
<hr/>

<p>
    When findUser returns, the Logon Action looks to see if a valid (non-null) User object is returned.
    A valid User is passed to the <strong>User</strong> property.
    The User property is not implemented in quite the same way as Username and Password.
</p>

<hr/>
<h5>MailreaderSupport.setUser</h5>
<pre><code>public User getUser() {
    return (User) <strong>getSession().get(Constants.USER_KEY)</strong>;
    }
    public void setUser(User user) {
    getSession().put(Constants.USER_KEY, user);
    }</code></pre>
<hr/>

<p>
    Instead of using a field to store the property value,
    setUser passes it to a <strong>Session</strong> property.
</p>

<h5>MailreaderSupport.getSession() and setSession()r</h5>
<pre><code>private Map session;

    public Map <strong>getSession()</strong> {
    return session;
    }

    public void <strong>setSession(Map value)</strong> {
    session = value;
    }</code></pre>

<p>
    To look at the MailreaderSupport class, the Session property looks like a plain-old Map.
    In fact, the Session property is an adapter that is backed by the servlet session object at runtime.
    The MailreaderSupport class doesn't need to know that though.
    It can treat Session like any other Map.
    We can also test the MailreaderSupport class by passing it some other implementation of Map,
    running the test,
    and then looking to see what changes MailreaderSupport made to our "mock" Session object.
</p>

<p>
    But, when MailreaderSupport is running inside a web application,
    how does it acquire a reference to the servlet session?
</p>

<p>
    Good question. If you were to look at just the MailreaderSupport class,
    you would not see a single line of code that sets the session property.
    But, yet, when we run the class, the session property is not null.
    Hmmm.
</p>

<p>
    The magic that provides the Session property a runtime value is called "dependency injection".
    The MailreaderSupport class implements a interface called <strong>SessionAware</strong>.
    SessionAware is bundled with the framework, and it defines a setter for the Session property.
</p>

<p>
    <code>public void <strong>setSession</strong>(Map session);</code>
</p>

<p>
    Also bundled with the framework is an object called the <strong>ServletConfigInterceptor</strong>.
    If the ServletConfigInterceptor sees that an Action implements the SessionAware interface,
    it automatically set the session property.
</p>

<pre><code> if (action instanceof <code>SessionAware</code>) {
    ((SessionAware) action).<code>setSession</code>(context.getSession());
    }</code></pre>

<p>
    The framework uses these "Interceptor" classes to create a "front controller"
    for each action an application defines.
    Each Interceptor can peek at the request before an Action class is invoked,
    and then again after the Action class is invoked.
    (If you have worked with Servlet
    <a href="http://java.sun.com/products/servlet/Filters.html">Filters</a>,
    you will recognize this pattern.
    But, unlike Filters, Interceptors are not tied to HTTP.
    Interceptors can be tested and developed outside of a web application.)
</p>

<p>
    You can use the same set of Interceptors for all your actions,
    or define a special set of Interceptors for any given action,
    or define different sets of Interceptors to use with different types of actions.
    The framework comes with a default set of Interceptors,
    that it will use when another set is not specified,
    but you can designate your own default Interceptor set (or "stack")
    in the xwork.xml configuration file.
</p>

<p>
    Most Interceptors provide a "utility" function, like setting the session property.
    Others, like the ValidationInterceptor, can change the workflow of an action.
    Interceptors are key feature of the framework,
    and we will see a few more on the tour.
</p>

<p>
    If a valid User is not found, or the password doesn't match,
    the findUser method invokes the <strong>addFieldError</strong> method to note the problem.
    When findUser returns, the Logon Action checks for errors,
    and then returns either INPUT or SUCCESS.
</p>

<p>
    The addFieldError method is provided by the ActionSupport class,
    which is bundled with the framework.
    The constants for INPUT and SUCCESS are also provided by ActionSupport.
    While the ActionSupport class provides many useful utilities,
    you are not required to use it as a base class.
    Any Java class can be used as an Action, if you like.
</p>

<p>
    But, it is a good practice to provide a base class with utilites
    that can be shared by an application's Action classes.
    The framework does this with ActionSupport,
    and the MailReader application does the same with the MailreaderSupport class.
</p>

<hr/>
<h5>Best Practice:</h5>
<blockquote>
    <p><font class="hint">"Use a base class to define common functionality."</font></p>
</blockquote>
<hr/>

<p>
    But, what happens if Logon returns INPUT instead of SUCCESS. How does the framework know what to do next?
</p>

<p>
    To answer that question,
    we need to turn back to the xwork.xml file and look at how Logon is configured.
</p>


<h4><a name="Logon.xml" id="Logon.xml">Logon Configuration</a></h4>

<p>
    The Logon action element outlines how the Logon workflow operates,
    including what to do when the Action returns "input",
    or the default result name "success".
</p>

<hr/>
<h5>xwork.xml Logon</h5>
<pre><code>&lt;action name="<strong>Logon</strong>" class="mailreader2.Logon">
    &lt;result name="<strong>input</strong>">/pages/Logon.jsp&lt;/result>
    &lt;result name="<strong>cancel</strong>" type="redirect-action">Welcome&lt;/result>
    &lt;result type="redirect-action">MainMenu&lt;/result>
    &lt;result name="<strong>expired</strong>" type="chain">ChangePassword&lt;/result>
    &lt;<strong>exception-mapping</strong>
    exception="org.apache.struts.apps.mailreader.dao.ExpiredPasswordException"
    result="<strong>expired</strong>"/>
    &lt;interceptor-ref name="<strong>defaultStack</strong>"/>
    &lt;/action></code></pre>
<hr/>

<p>
    In the Logon action element, the first result element is named "input".
    If validation or the credentials fail,
    the Action class will return "input" and the framework will transfer control to the Logon.jsp page.
</p>

<p>
    The second result element is named "cancel".
    If someone presses the cancel button on the Logon page,
    the Action class will return "cancel", this result will be selected,
    and the framework will issue a redirect to the Welcome action.
</p>

<p>
    The third result has no name,
    so it will be called if the default "success" token is returned.
    So, if the Logon succeeds,
    control will transfer to the MainMenu action.
</p>

<p>
    The MailReader DAO exposes a "ExpiredPasswordException".
    If the DAO throws this exception when the User logs in,
    the framework will process the exception-mapping
    and transfer control the the "ChangePassword" action.
</p>

<p>
    Just in case any other Exceptions are thrown,
    the MailReader application also defines a global handler.
</p>

<hr/>
<h5>xwork.xml exception-mapping</h5>
<pre><code>&lt;global-exception-mappings>
    &lt;exception-mapping
    result="error"
    exception="java.lang.Exception"/>
    &lt;/global-exception-mappings></code></pre>
<hr/>

<p>
    If an unexpected Exception is thrown,
    the exception-mapping will transfer control to the action's "error" result,
    or to a global "error" result.
    The Mailreader defines a global "error" result
    which transfers control to an "Error.jsp" page
    that can display the error message.
</p>

<hr/>
<h5>Error.jsp</h5>
<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8" %>
    &lt;%@ taglib uri="/webwork" prefix="saf" %>
    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    &lt;head>
    &lt;title>Unexpected Error&lt;/title>
    &lt;/head>
    &lt;body>
    &lt;h2>An unexpected error has occured&lt;/h2>
    &lt;p>
    Please report this error to your system administrator
    or appropriate technical support personnel.
    Thank you for your cooperation.
    &lt;/p>
    &lt;hr />
    &lt;h3>Error Message&lt;/h3>
    <strong>&lt;saf:actionerror /></strong>
    &lt;p>
    <strong>&lt;saf:property value="%{exception.message}"/></strong>
    &lt;/p>
    &lt;hr />
    &lt;h3>Technical Details&lt;/h3>
    &lt;p>
    <strong>&lt;saf:property value="%{exceptionStack}"/></strong>
    &lt;/p>
    &lt;jsp:include page="Footer.jsp"/>
    &lt;/body>
    &lt;/html></code></pre>
<hr/>

<p>
    The Error page uses <strong>property</strong> tags to expose
    the Exception message and the Exception stack.
</p>

<p>
    Finally, the Logon action specifies an InterceptorStack named "defaultStack".
    If you've worked with Action 2 or WebWork 2 before, that might seem strange,
    since "defaultStack" is the factory default.
</p>

<p>
    In the MailReader application, most of the actions are only available
    to authenticated users.
    The exceptions are the "Welcome" action and the "Logon" action,
    which are available to everyone.
    To authenticate clients,
    the MailReader uses a custom Interceptor and a custom Interceptor stack.
</p>

<hr/>
<h5>mailreader2.AuthenticationInterceptor</h5>
<pre><code>package mailreader2;
    import com.opensymphony.xwork.interceptor.Interceptor;
    import com.opensymphony.xwork.ActionInvocation;
    import com.opensymphony.xwork.Action;
    import java.util.Map;
    import org.apache.struts.apps.mailreader.dao.User;

    public class <strong>AuthenticationInterceptor</strong> implements Interceptor {
    public void destroy () {}
    public void init() {}
    public String <strong>intercept</strong>(ActionInvocation actionInvocation) throws Exception {
    Map session = actionInvocation.getInvocationContext().getSession();
    User user = (User) session.get(Constants.USER_KEY);
    boolean isAuthenticated = (null!=user) && (null!=user.getDatabase());
    if (<strong>isAuthenticated</strong>) {
    return actionInvocation.invoke();
    }
    else {
    return Action.LOGIN;
    }
    }
    }</code></pre>
<hr/>

<p>
    The "AuthenticationInterceptor" looks to see if a User object
    has been stored in the client's session state.
    If so, it returns normally, and the next Interceptor in the set would be invoked.
    If the User object is missing, the Interceptors returns "login".
    The framework would match "login" to the global result,
    and transfer control to the Logon action.
</p>

<p>
    The MailReader defines two custom Interceptor stacks, <strong>access</strong>
    and <strong>submit</strong>, and sets the default-interceptor to "access".
</p>

<hr/>
<h5>xwork.xml interceptors</h5>
<pre><code>&lt;interceptors>
    &lt;interceptor name="<strong>authenticate</strong>" class="mailreader2.AuthenticationInterceptor"/>
    &lt;interceptor-stack name="<strong>access</strong>" >
    &lt;interceptor-ref name="authenticate" />
    &lt;interceptor-ref name="defaultStack"/>
    &lt;/interceptor-stack>
    &lt;interceptor-stack name="<strong>submit</strong>">
    &lt;interceptor-ref name="token-session" />
    &lt;interceptor-ref name="<strong>access</strong>" />
    &lt;/interceptor-stack>
    &lt;/interceptors>

    &lt;<strong>default-interceptor-ref</strong> name="access"/></code></pre>
<hr/>

<p>
    The "submit" stack is to be used with actions that post forms.
    It includes the "token-session" Interceptor which guards against double-submits,
    and then goes to include the "access" interceptor stack.
    The "access" stack includes the authenticate Interceptor,
    and then falls back to the standard "defaultStack".
</p>

<h5>Double Submits</h5>

<p>
    A common problem with designing web applications is that response times
    can vary and users are impatient.
    Sometimes, people will press a submit button a second time.
    When this happens, the browser submits the request again,
    so that we now have two requests for the same thing.
    In the case of registering a user, if someone does press the submit button
    again, and their timing is bad,
    it could result in the system reporting that the username has already been
    used.
    (The first time the button was pressed.)
    In practice, this would probably never happen, but for a longer running
    process, like checking out a shopping cart,
    it's easier for a double submit to occur.
</p>

<p>
    To forestall double submits and "back button" resubmit,
    the framework can generate a token that is embedded in the form
    and also kept in the session.
    If the value of the tokens do not compare,
    then we know that there has been a problem,
    and a form has been submitted twice or out of sequence.
</p>

<p>
    The Token Session Interceptor will also attempt to provide intelligent
    fail-over in the event of multiple requests using the same session.
    That is, it will block subsequent requests until the first request is complete,
    and then instead of returning the invalid. token code,
    it will attempt to display the same response that the
    original, valid action invocation would have displayed
</p>

<p>
    Because the default interceptor stack will now authenticate the client,
    we need to specify the standard "defaultStack" for the two "anonymous actions",
    Welcome and Logon.
</p>

<h3><a name="MainMenu" id="MainMenu">MainMenu</a></h3>

<p>
    On a successful logon, the Main Menu page displays.
    If you logged in using the demo account,
    the page title should be "Main Menu Options for John Q. User".
    Below this legend should be two links:
</p>

<ul>
    <li>
        Edit your user registration profile
    </li>
    <li>
        Log off MailReader Demonstration Application
    </li>
</ul>

<p>
    Let's review the source for the "MainMenu" action mapping,
    and the "MainMenu.jsp".
</p>

<hr/>
<h5>Action mapping element for MainMenu</h5>
<pre><code>&lt;action name="MainMenu" class="mailreader2.MailreaderSupport">
    &lt;result>/pages/MainMenu.jsp&lt;/result>
    &lt;/action></code></pre>

<h5>MainMenu.jsp</h5>
<pre><code>&lt;%@ page contentType="text/html; charset=UTF-8" %>
    &lt;%@ taglib uri="/webwork" prefix="saf" %>
    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    &lt;head>
    &lt;title>&lt;saf:text name="mainMenu.title"/>&lt;/title>
    &lt;link href="&lt;saf:url value="/css/mailreader.css"/>" rel="stylesheet"
    type="text/css"/>
    &lt;/head>

    &lt;body>
    &lt;h3>&lt;saf:text name="mainMenu.heading"/> <strong>&lt;saf:property
    value="user.fullName"/></strong>&lt;/h3>
    &lt;ul>
    &lt;li>&lt;a href="&lt;saf:url <strong>action="Registration!input"</strong> />">
    &lt;saf:text name="mainMenu.registration"/>
    &lt;/a>
    &lt;/li>
    &lt;li>&lt;a href="&lt;saf:url <strong>action="Logoff"</strong> />">
    &lt;saf:text name="mainMenu.logoff"/>
    &lt;/a>
    &lt;/ul>
    &lt;/body>
    &lt;/html></code></pre>
<hr/>

<p>
    The source for MainMenu.jsp also contains a new tag, <strong>
    property</strong>, which we use to customize the page with the
    full name property of the authenticated user.
</p>

<p>
    Displaying the user's full name is the reason the MainMenu action
    references the MailreaderSupport class.
    The MailreaderSupport class has a user property that the text tag
    can access.
    If we did not utilize MailreaderSupport,
    the property tag would not be able to find the User object to print
    the full name.
</p>

<p>
    The customized MainMenu page offers two standard links.
    One is to "Edit your user registration profile".
    The other is to "Logoff the MailReader Demonstration Application".
</p>

<h3><a name="Registration.jsp" id="Registration.jsp">Registration page</a>
</h3>

<p>
    If you follow the "Edit your user registration profile" link from the Main
    Menu page,
    we will finally reach the heart of the MailReader application: the
    Registration, or "Profile", page.
    This page displays everything MailReader knows about you
    (or at least your login),
    while utilizing several interesting techniques.
</p>

<p>
    To do double duty as the "Create" Registration page" and the "Edit"
    Registration page,
    the Registration.jsp makes extensive use of the test tags,
    to make it appears as though there are two distinct pages.
</p>

<h5>MainMenu.jsp - head element</h5>
<pre><code>&lt;head>
  &lt;saf:if test="task=='Create'">
    &lt;title>&lt;saf:text name="registration.title.create"/>&lt;/title>
  &lt;/saf:if>
  &lt;saf:if test="task=='Edit'">
    &lt;title>&lt;saf:text name="registration.title.edit"/>&lt;/title>
  &lt;/saf:if>
  &lt;link href="&lt;saf:url value="/css/mailreader.css"/>" rel="stylesheet"
    type="text/css"/>
&lt;/head></code></pre>

<p>
    For example, if you are editing the form (task == 'Edit'),
    the page inserts your username from the RegistrationForm bean.
    If you are new user (task == 'Create'), the page creates an empty field,
    so you can pick your username.

</p>

<hr/>
<h5>Note:</h5>
<blockquote>
    <p><font class="hint">
        <strong>Presention Logic</strong> -
        The "test" tag is a convenient way to express presentation
        logic within your pages.
        Customized pages help to prevent user error,
        and dynamic customization reduces the number of JSPs your application
        needs to maintain, among other benefits.
    </font></p>
</blockquote>
<hr/>

<p>
    The page also uses logic tags to display a list of subscriptions for the
    given user.
    If the RegistrationForm has task set to "Edit",
    the lower part of the page that lists the subscriptions is exposed.
</p>

<hr/>
<h5></h5>
<pre><code>&lt;saf:if test=<strong>"task == 'Edit'"</strong>>
  &lt;div align="center">
    &lt;h3>&lt;saf:text name="heading.subscriptions"/>&lt;/h3>
  &lt;/div>
    &lt;!-- ... -->
  &lt;/saf:if>
&lt;jsp:include page="Footer.jsp"/>
&lt;/body>&lt;/html></code></pre>
<hr/>

<p>
    Otherwise, the page contains just the top portion --
    a data-entry form for managing the user's registration.
</p>

<h4><a name="iterator" id="iterator">iterator</a></h4>

<p>
    Besides "if" there are several other control tags that you can use
    to sort, filter, or iterate over data.
    The Registration page includes a good example of using the <strong>iterator</strong>
    tag to display the user's subscriptions.
</p>

<p>
    The subscriptions are stored in a hashtable object, which is in turn
    stored in the user object.
    So to display each subscription, we have to reach into the user object,
    and loop through the members of the subscription collection.
    Using the iterator tag, you can code it the way it sounds.
 /p>

<hr/>
<h5>Using iterator to list the Subscriptions</h5>
<pre><code>&lt;saf:iterator value="<strong>user.subscriptions</strong>">
  &lt;tr>
    &lt;td align="left">
      &lt;saf:property value="host"/>
    &lt;/td>
    &lt;td align="left">
       &lt;saf:property value="username"/>
   &lt;/td>
  &lt;td align="center">
      &lt;saf:property value="type"/>
  &lt;/td>
  &lt;td align="center">
     &lt;saf:property value="autoConnect"/>
  &lt;/td>
  &lt;td align="center">
    &lt;a href="&lt;saf:url action="<strong>Subscription!delete</strong>">&lt;saf:param name="<strong>host</strong>" value="host"/>&lt;/saf:url>">
      &lt;saf:text name="registration.deleteSubscription"/>
    &lt;/a>&nbsp;
    &lt;a href="&lt;saf:url action="<strong>Subscription!edit</strong>">&lt;saf:param name="<strong>host</strong>" value="host"/>&lt;/saf:url>">
      &lt;saf:text name="registration.editSubscription"/>
     &lt;/a>
   &lt;/td>
 &lt;/tr>
&lt;/saf:iterator></code></pre>
<hr/>

<p>
    When the iterator renders, it generates a list of subscriptions for the current user.
</p>

<hr />

    <div align="center">
        <h3>Current Subscriptions</h3>
    </div>

    <table border="1" width="100%">
        <tr>
            <th align="center" width="30%">
                Host Name
            </th>
            <th align="center" width="25%">
                User Name
            </th>

            <th align="center" width="10%">
                Server Type
            </th>
            <th align="center" width="10%">
                Auto
            </th>
            <th align="center" width="15%">
                Action
            </th>
        </tr>
            <tr>
                <td align="left">
                    mail.hotmail.com
                </td>
                <td align="left">
                    user1234
                </td>
                <td align="center">
                    pop3
                </td>

                <td align="center">
                    false
                </td>
                <td align="center">
                    <a href="/action2-mailreader/Subscription!delete.do?host=mail.hotmail.com">
                        Delete
                    </a>
                    &nbsp;
                    <a href="/action2-mailreader/Subscription!edit.do?host=mail.hotmail.com">
                        Edit
                    </a>
                </td>
            </tr>
            <tr>
                <td align="left">
                    mail.yahoo.com
                </td>
                <td align="left">
                    jquser
                </td>
                <td align="center">
                    imap
                </td>
                <td align="center">
                    false
                </td>
                <td align="center">
                    <a href="/action2-mailreader/Subscription!delete.do?host=mail.yahoo.com">
                        Delete
                    </a>
                    &nbsp;
                    <a href="/action2-mailreader/Subscription!edit.do?host=mail.yahoo.com">
                        Edit
                    </a>
                </td>
            </tr>
    </table>
    <a href="/action2-mailreader/Subscription!input.do">Add</a>

<hr />

    <p>
        Now look back at the code used to generate this block.
    </p>
    <p>
        Notice anything nifty?
    </p>
    <p>
        How about that the markup between the iterator tag is
        actually <em>simpler</em> than the markup that we would use to render one row of the table?
    </p>
    <p>
        Instead of using a qualified reference  like "value=user.subscription[0].host",
        we use the simplest possible reference: "value=host".
        We didn't have to define a local variable, and reference that local in the loop code.
        The reference to each item in the list is automatically resolved, no fuss, no muss.
    </p>
    <p>
        Hmmm. Nice trick!
    </p>

<p>
    The secret to this magic is the <strong>value stack</strong>.
    Next to Interceptors, the value stack is probably the coolest thing there is about the framework.
    To explain the value stack, let's step back and start from the beginning.
</p>

<p>
    Merging dynamic data into static web pages is a primary reason
    we create web applications.
    The JavaServer Pages API has a mechanism that allows you to
    place objects in a servlet scope (page, request, session, or
    application), and then retrieve them using a scriplet.
    If the object is placed directly in one of the scopes,
    a JSP tag can find that object by searching page scope  and
    then request scope, and session scope, and finally application scope.
</p>

<p>
    The value stack works much the same way, only better.
    When you push an object on the value stack,
    the public properties of that object become first-class properties of the stack.
    The object's properties become the stack's properties.
    If another object on the stack has properties of the same name,
    the last object pushed onto the stack wins.
</p>

<p>
    When the iterator tag loops through a collection,
    it pushes each item in the collection onto the stack.
    The item's properties become the stack's property.
    In the case of the subscriptions,
    if the subscription has a public "host" property,
    then during that iteration,
    the stack can access the same property.
</p>

<p>
    Of course, at the end of each iteration, the tag "pops" the item off the stack.
    If we were to try and access the host property later in the page,
    it won't be there.
</p>

<p>
    When an Action is invoked, the Action class is pushed onto the value stack.
    Since the Action is on the value stack,
    our tags can access any property of the Action as if it were an implicit property of the page.
    The tags don't access the Action directly.
    If a textfield tag is told to render the "username" property,
    the tag asks the value stack for the value of "username", 
    and the value stack returns the first property it finds by that name.
</p>

<p>
    The Validators also use the stack.
    When validation fails on a field,
    the value for the field is pushed onto the value stack.
    As a result, if the client enters text into an Integer field,
    the framework can still redisplay whatever was entered.
</p>

<p>
    The Subscription list uses another new tag: the <strong>param</strong> tag.
</p>

<!-- TODO ... -->

<p>
    Next to each entry in the subscription list are links to Delete and Edit
    commands.
    These links use the same name/property/id trinity as the interator,
    except that the attributes are used to create a hyperlink with a single
    parameter.
    (Multiple parameters are possible too, but if the code is well-factored,
    one should be sufficient.)
</p>

<p>
    Given a subscription to "mail.yahoo.com",
    the command links would translate to HTML links like these:
</p>

<hr/>
<h5>The Delete and Edit links for mail.yahoo.com</h5>
<pre><code>      &lt;a
    href="/struts-mailreader/DeleteSubscription.do?host=mail.yahoo.com">Delete&lt;/a>
    &nbsp;
    &lt;a
    href="/struts-mailreader/EditSubscription.do?host=mail.yahoo.com">Edit&lt;/a></code>
</pre>
<hr/>

<p>
    At the foot of the Register page is a link for adding a subscription.
    Let's wind up the tour by following the Add link and then logging off.
    Like the link for creating a Registration, Add points to an "Edit" action,
    namely "EditSubscription".
</p>




<h4>
    <a name="SubscriptionAction.java" id="SubscriptionAction.java">SubscriptionAction.java</a>
</h4>

<p>
    The EditSubscription link shares the Wildcard "/Edit*" mapping we saw with
    EditRegistration.
    As before, in the case of "Edit<em>Subscription</em>",
    the "{1}Form" attribute maps to <strong>SubscriptionForm</strong>.
</p>

<hr/>
<h5>The SubscriptionAction form-bean element</h5>
<pre><code>        &lt;form-bean
    name="SubscriptionForm"
    extends="BaseForm">
    &lt;form-property
    name="autoConnect"
    <strong>type="java.lang.Boolean"
        initial="FALSE"
        reset="true"</strong>/>
    &lt;form-property
    name="host"
    type="java.lang.String" />
    &lt;form-property
    name="type"
    type="java.lang.String" />
    &lt;/form-bean></code></pre>
<hr/>

<p>
    The other DynaActionForms we've seen used only String properties.
    SubscriptionForm is different in that it uses a Boolean type for the
    "autoConnect" property.
    On the HTML form, the autoConnect field is represented by a checkbox,
    and checkboxes need to be handled differently that other controls.
</p>

<hr/>
<h5>Tip:</h5>
<blockquote>
    <p class="hint">
        <strong>Checkboxes</strong> -
        The HTML checkbox is a tricky control.
        The problem is that, according to the W3C specification, a value is
        only guaranteed to be sent
        if the control is checked.
        If the control is not checked, then the control may be omitted from
        the request, as if it was on on the page.
        This can cause a problem with session-scope checkboxes.
        Once you set the checkbox to true, the control can't set it to false
        again,
        because if you uncheck the box, nothing is sent, and so the control
        stays checked.
    </p>

    <p class="hint">
        The simple solution is to set the initial value for a checkbox control
        to false before the form is populated.
        If the checkbox is checked, it will return a value, and the checkbox
        will represent true.
        If the checkbox is unchecked, it will not return a value, and the
        checkbox will remain unchecked ("false").
    </p>
</blockquote>
<hr/>

<p>
    To be sure the autoConnect checkbox is handled correctly,
    the SubscriptionForm initializes the property to FALSE,
    and enables "reset" so that before autopopulation the property is set back
    to FALSE.
</p>

<p>
    The SubscriptionAction Edit method should look familiar, but it also has a
    few twists of its own.
</p>

<hr/>
<h5>SubscriptionAction.Edit</h5>
<pre><code>public ActionForward Edit(
    ActionMapping mapping,
    ActionForm form,
    HttpServletRequest request,
    HttpServletResponse response)
    throws Exception {

    final String method = Constants.EDIT;
    doLogProcess(mapping,method);

    HttpSession session = request.getSession();
    User user = doGetUser(session);
    <strong>if (user==null) return doFindLogon(mapping);</strong>

    // Retrieve the subscription, if there is one
    Subscription subscription;
    <strong>String host = doGet(form,HOST);
        boolean updating = (host!=null);</strong>
    if (updating) {
    subscription = <strong>doFindSubscription</strong>(user,host);
    if (subscription==null) return <strong>doFindFailure</strong>(mapping);
    session.setAttribute(Constants.SUBSCRIPTION_KEY, subscription);
    <strong>doPopulate</strong>(form,subscription);
    doSet(form,TASK,method);
    }

    return doFindSuccess(mapping);
    }</code></pre>
<hr/>

<p>
    In RegistrationAction.Edit, we looked for the user object to decide if we
    were updating or inserting.
    In SubscriptionAction.Edit, the user object is required (and we trot off
    to the Login page if it is missing).
    This could happen because a session expired, or because someone bookmarked
    a page.
</p>

<p>
    To decide if we are inserting or updating a subscription,
    we look to see if the <strong>host</strong> is set to the ActionForm.
    If it is an update, we fetch the Subscription from the database.
</p>

<hr/>
<h5>SubscriptionAction.doFindSubscription</h5>
<pre><code> private Subscription <strong>doFindSubscription</strong>(User
    user, String host) {

    Subscription subscription;

    try {
    subscription = user.findSubscription(host);
    }
    catch (NullPointerException e) {
    subscription = null;
    }

    if ((subscription == null) && (log.isTraceEnabled())) {
    log.trace(
    " No subscription for user "
    + user.getUsername()
    + " and host "
    + host);
    }

    return subscription;
    }</code></pre>
<hr/>

<p>
    If we can't find the subscription,
    we use <strong>doFindFailure</strong> to forward to the Failure result
    (Error.jsp).
</p>

<hr/>
<h5>BaseAction.doFindFailure</h5>
<pre><code> protected ActionForward <strong>doFindFailure</strong>
    (ActionMapping mapping) {
    if (log.isTraceEnabled()) {
    log.trace(Constants.LOG_FAILURE);
    }
    return (mapping.findForward(Constants.FAILURE));
    }
</code></pre>
<hr/>

<p>
    In the normal course, the subscription should always be found,
    since we selected the host from a system-generated list.
    If the subscription is not found,
    it would be because the database disappeared or the request is being
    spoofed.
</p>

<p>
    Like the RegisterAction, the <strong>doPopulate</strong> method transfers
    data from the form to the domain
    object. In this case, a Subscription object.
</p>

<hr/>
<h5>SubscriptionAction.doPopulate</h5>
<pre><code> private void <strong>doPopulate</strong>(ActionForm form,
    Subscription subscription) throws ServletException {

    final String title = Constants.EDIT;

    if (log.isTraceEnabled()) {
    log.trace(Constants.LOG_POPULATE_FORM + subscription.getHost());
    }

    try {
    <strong>PropertyUtils.copyProperties(form, subscription);</strong>
    doSet(form,TASK,title);
    } catch (InvocationTargetException e) {
    Throwable t = e.getTargetException();
    if (t == null) t = e;
    log.error(LOG_SUBSCRIPTION_POPULATE, t);
    throw new ServletException(LOG_SUBSCRIPTION_POPULATE, t);
    } catch (Throwable t) {
    log.error(LOG_SUBSCRIPTION_POPULATE, t);
    throw new ServletException(LOG_SUBSCRIPTION_POPULATE, t);
    }
    }</code></pre>
<hr/>

<p>
    Most of the code in "doPopulate" is window dressing for the call to
    <strong>PropertyUtils.copyProperties</strong>, which does the heavy
    lifting.
</p>

<p>
    But before turning to our final JSP, a word about our database model ...
</p>

<h4>
    <a name="User.java" id="User.java">User.java</a> and <a
        name="Subscription.java" id="Subscription.java">Subscription.java</a>
</h4>

<p>
    If you're used to working with relational databases,
    the links between the user and subscription objects may be confusing.
    A conventional relational database would create two distinct tables,
    one for the users and another for the subscriptions,
    and link them together with a user ID.
    The MailReader application implements a different model, a hierarchical
    database.
    Here a "table" of subscriptions is stored within each user object,
    something like the way a filing system stores documents within folders.
</p>

<p>
    Development teams often use frameworks like <a
        href="http://www.objectstyle.org/cayenne/">Cayenne</a>
    to map a relational database to a hierarchy of objects,
    like the one used by MailReader.
    For simplicity, the MailReader doesn't use a conventional database, but
    saves its data as an XML file.
    While the MailReader is running, the database is kept in main memory, and
    written to back to disk when changed.
</p>

<p>
    In addition to the usual getters and setters,
    the user object also has two methods for working with subscription
    objects.
    The <strong>findSubscription</strong> method takes a hostname and returns
    the subscription object for that host.
    The <strong>getSubscriptions</strong> method returns an array of all the
    subscriptions for the user
    (ready-made for the iterate tag!).
    Besides the fields needed to manage the SubscriptionForm data,
    the object also maintains a runtime link to its own user object.
</p>

<p>
    To create a new subscription,
    SubscriptionAction.java simply creates a new subscription object,
    and sets its user to the object found in the request,
    and then forwards control to its input form, Subscription.jsp.
</p>

<h3><a name="subcription.jsp" id="subcription.jsp">Subscription.jsp</a></h3>

<p>
    Saving the best for last, Subscription.jsp utilizes two interesting Struts
    custom form tags,
    "html:options" and "html:checkbox".

<p>
    In Registration.jsp, the Struts iteration tag was used to write a list of
    subscriptions.
    Another place where iterations and collections are handy is the option
    list for a HTML select tag.
    Since this is such a common situation, Struts offers a html:options
    (plural) tag
    that can take an array of objects as a parameter.
    The tag then iterates over the members of the array (beans) to place each
    one inside an standard option tag.
    So given a block like</p>

<pre><code>&lt;html:select property="type"&gt;
    &lt;html:options
    collection="serverTypes"
    property="value"
    labelProperty="label" /&gt;
    &lt;/html:select&gt;</code></pre>

<p>The tag outputs a block like</p>

<pre><code>&lt;select name="type"&gt;
    &lt;option value="imap" selected&gt;IMAP Protocol&lt;/option&gt;
    &lt;option value="pop3"&gt;POP3 Protocol&lt;/option&gt;
    &lt;/select&gt;</code></pre>

<p>
    Here, one collection contained both the labels and the values, from
    properties of the same name.
    Options can also use a second array for the labels, if they do not match
    the values.
    Options can use a Collection, Iterator, or Map for the source of the list.
</p>

<p>
    Unlike other data, the serverTypes array is not fetched from the database.
    Instead, it is loaded by a Struts plugin.
    The <strong>DigestingPlugin</strong> parses an XML document using a given
    set of Digester rules.
    The MailReader uses a set of rules for "LabelValueBeans" to create a list
    of server types.
</p>

<hr/>
<h5>Tip:</h5>
<blockquote>
    <p><font class="hint">
        <strong>LabelValueBeans</strong> -
        Many developers find the LabelValueBeans useful,
        so the class is available in the Struts Action distribution as
        [org.apache.struts.util.LabelValueBean].
    </font></p>
</blockquote>
<hr/>

<p>
    The plugin stores the list is stored in application scope.
    Since the Struts custom tags, like standard JSP tags, search the scopes in
    succession,
    the tag finds the list in application scope and uses it to write out the
    options.
</p>


<h4><a name="SubscriptionForm.java" id="SubscriptionForm.java">SubscriptionForm.java</a>
</h4>

<p>
    Back in Subscription.jsp, we have one more block to cover.
    Although the same basic form can be used to created, edit, or delete a
    subscription,
    people might expect the buttons to be labeled differently in each case.
    Like the Registration page, the Subscription page handles customization
    by using a logic tag to output a different set of buttons for each case.
    Changing buttons doesn't really change the way the Subscription page
    works,
    but customizing the buttons does make things less confusing for the user.
</p>

<pre><code>&lt;logic:equal
    name="SubscriptionForm"
    <strong>property="task"</strong>
    scope="request"
    value="Create"&gt;
    &lt;html:submit&gt;
    <b>&lt;bean:message key="button.save"/&gt;<br/></b> &lt;/html:submit&gt;
    &lt;/logic:equal&gt;</code></pre>

<p>
    In the case of a request to delete a subscription,
    the submit button is labeled "Confirm", since this view is meant to give
    the user a last chance to cancel,
    before sending that task along to SaveSubscriptionAction.java.
</p>

<p>
    The actual task property is placed into the form as a hidden field,
    and SaveSubscriptionAction uses that property to execute the appropriate
    task.
</p>

<h4><a name="SubscriptionAction.java" id="SubscriptionAction.java">SubscriptionAction.java</a>
</h4>

<p>
    Our final stop has the job of finishing what SubscriptionAction.Edit
    started.
    After the usual logic and error checking,
    The SubscriptionAction.Save method either deletes or updates
    the subscription object being handled by this request,
    and cleans up the bean, just to be tidy.
    By now, you should be very comfortable reading through the source on your
    own, to pickup the finer points.
</p>

<hr/>
<h5>SubscriptionAction.Save</h5>
<pre><code> public ActionForward <strong>Save</strong>(
    ActionMapping mapping,
    ActionForm form,
    HttpServletRequest request,
    HttpServletResponse response)
    throws Exception {

    final String method = Constants.SAVE;
    doLogProcess(mapping,method);

    User user = doGetUser(request);
    if (user == null) {
    return doFindLogon(mapping);
    }

    HttpSession session = request.getSession();
    if (isCancelled(request)) {
    <strong>doCancel</strong>(session,method,Constants.SUBSCRIPTION_KEY);
    return doFindSuccess(mapping);
    }

    String action = doGet(form,TASK);
    Subscription subscription = <strong>doGetSubscription</strong>(request);
    boolean isDelete = action.equals(Constants.DELETE);
    if (isDelete) {
    return <strong>doRemoveSubscription</strong>
    (mapping,session,user,subscription);
    }

    if (subscription==null) {
    subscription = <strong>user.createSubscription</strong>(doGet(form,HOST));
    session.setAttribute(Constants.SUBSCRIPTION_KEY,subscription);
    }

    doPopulate(subscription,form);
    <strong>doSaveUser</strong>(user);
    session.removeAttribute(Constants.SUBSCRIPTION_KEY);

    return doFindSuccess(mapping);
    }</code></pre>
<hr/>

<p>
    This concludes our tour.
    To review, you may wish to trace the path a new user takes
    when they register with the application for the first time.
    You should also read over each of the .java and JSP files carefully,
    since we only covered the high points here.
</p>

<h3><a name="Review" id="Review">Review</a></h3>

<ul>
    <li>Struts uses a single controller servlet to route HTTP requests.</li>

    <li>The requests are routed to action objects according to path (or
        URI).</li>

    <li>Each request is handled as a separate thread</li>

    <li>There is only one object for each action (URI), so your action objects
        must be multi-thread safe.</li>

    <li>The configuration of action objects are loaded from a XML resource
        file, rather than hardcoded.</li>

    <li>Action objects can respond to the request, or ask the controller to
        forward the request to another object or to another page, such as an
        input form.</li>

    <li>A library of custom tags works with the rest of the framework to
        enhance use of JavaServer Pages.</li>

    <li>The Struts form tag can work closely with an action objects via a
        Struts ActionFormBean to retain the state of a data-entry form, and
        validate the data entered.</li>

    <li>ActionForm beans can be automatically created by the JSP form or
        controller servlet.</li>

    <li>Struts supports a message resource for loading constants strings.
        Alternate message resources can be provided to internationalize an
        application.</li>
</ul>
<hr/>
</blockquote>
</body>
</html>
